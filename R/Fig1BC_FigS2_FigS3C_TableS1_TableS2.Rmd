---
title: "Figure 1 BC, Figure S2, Figure S3 C, Table S1, Table S2"
author:
  - name: "Emir Turkes and Stephanie Fowler"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
link-citations: true
output:
  html_document:
    code_folding: show
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(
    "..", "results", "Fig1BC_FigS2_FigS3C_TableS1_TableS2.html"
  ))})
---

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This file is a part of [AD-EV-characterisation](https://github.com/duff-lab-team/AD-EV-characterisation)*  
*The purpose of this file is to reproduce results from the associated paper, specifically sections B and C of Figure 1, Supplementary Figure 2, section C of Supplementary Figure S3, and Supplementary Tables 1 and 2.*

To toggle the visibility of code, use the `CODE` toggles at the top right of chunks.
The toggle at the start of the document controls the visibility of all chunks.
Note that the chunk options `results = "hide"` and `fig.show = "hide"` are used to suppress any output that is not a result in the paper, in order to keep this document clean and focused.

# Prep

This section covers necessary but non-directly relevant code for generating the main sections.

```{r, results = "hide", fig.show = "hide"}
#    This file is part of AD-EV-characterisation.
#    Copyright (C) 2022  Emir Turkes, Stephanie Fowler, UK DRI at UCL, Columbia
#    University Medical Center
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

# Load required packages, suppressing startup messages.
# -----------------------------------------------------
packages <- c(
  "conflicted", "ComplexHeatmap", "DEP", "khroma", "ggplot2", "SummarizedExperiment", "magrittr", "tibble", "dplyr",
  "scales", "limma", "DT", "GSEABase", "GSVA", "biomaRt", "circlize"
)
invisible(suppressPackageStartupMessages(lapply(packages, FUN = library, character.only = TRUE)))
# -----------------------------------------------------

# Define global settings.
# -----------------------
knitr::opts_chunk$set(fig.width = 10, fig.height = 7, dev = "svglite")
ht_opt$message <- FALSE # Turn off messages to use rasterisation when plotting large matrices.
# -----------------------

# Define functions.
# -----------------
`%notin%` <- Negate(`%in%`)

# Adds download button and horizontal scrolling to `DT::datatable`.
# -----------------------------------------------------------------
datatable_download <- function(dt) {
  datatable(
    dt,
    options = list(
      scrollX = TRUE, dom = "Blfrtip", buttons = list("copy", list(extend = "csv", text = "Download CSV"))
    ),
    extensions = "Buttons"
  )
}
# -----------------------------------------------------------------
# -----------------

# Commonly used paths.
# --------------------
data_dir <- file.path("..", "data")
cache_dir <- file.path("..", "tmp", "proteins") # Store intermediate data objects here.
if (!dir.exists(cache_dir)) {
  dir.create(cache_dir, recursive = TRUE)
}
# --------------------

# Read in data.
# -------------
data <- read.delim(file.path(data_dir, "proteomics", "20220404_DOB_AllPatients_v1.pg_matrix.tsv"))
# -------------

# The first sample, at column 6, is actually Fraction 1 of Donor B and should be moved with the rest of Donor B.
# --------------------------------------------------------------------------------------------------------------
tmp1 <- data[ , 1:5]
tmp2 <- as.data.frame(data[ , 6])
colnames(tmp2) <- colnames(data)[6]
tmp3 <- data[ , 7:14]
tmp4 <- data[ , 15:ncol(data)]
data <- cbind(tmp1, tmp3, tmp2, tmp4)
rm(tmp1, tmp2, tmp3, tmp4)
# --------------------------------------------------------------------------------------------------------------

data <- data[ , c(1:5, c(1:32, 41:48, 33:40, 57:64, 49:56) + 5)] # Reorder some donors to match order in Zetaview data.

# Assign usable sample labels.
# ----------------------------
colnames(data) <- c(
  colnames(data)[1:5],
  paste(paste0("F", seq(8)), rep("A", times = 8), sep = " "),
  paste(paste0("F", seq(8)), rep("B", times = 8), sep = " "),
  paste(paste0("F", seq(8)), rep("C", times = 8), sep = " "),
  paste(paste0("F", seq(8)), rep("D", times = 8), sep = " "),
  paste(paste0("F", seq(8)), rep("E", times = 8), sep = " "),
  paste(paste0("F", seq(8)), rep("F", times = 8), sep = " "),
  paste(paste0("F", seq(8)), rep("G", times = 8), sep = " "),
  paste(paste0("F", seq(8)), rep("H", times = 8), sep = " ")
)
# ----------------------------

# Remove outlier samples.
# -----------------------
remove <- which(colnames(data) == "F8 A" | colnames(data) == "F8 E" | colnames(data) == "F8 F")
data <- data[ , -remove]
# -----------------------

LFQ_columns <- 6:66

# Reorder samples by fraction rather than donor.
# ----------------------------------------------
data <- data[ , c(1:5, (order(substring(colnames(data)[LFQ_columns], first = 2, last = 2)) + 5))]
# ----------------------------------------------

# Clean up protein identities.
# ----------------------------
remove <- which(data$Genes == "")
if (length(remove > 0)) {
  data <- data[-remove, ]
}
data <- make_unique(data, names = "Genes", ids = "Protein.Ids")
# ----------------------------

# Create a data frame for metadata.
# Some columns are required for use with DEP.
# -------------------------------------------
experimental_design <- data.frame(
  label = colnames(data)[6:66],
  condition = paste0("Fraction ", substring(colnames(data)[LFQ_columns], first = 2, last = 2)),
  replicate = c(rep(1:8, times = 7), 2:4, 7:8),
  donor = substring(colnames(data)[LFQ_columns], first = 4),
  groups = c(rep("F1_3", times = 24), rep("F4_6", times = 24), rep("F7_8", times = 13)) # Fraction groups to compare.
)
experimental_design$nice_names <- paste(experimental_design$condition, experimental_design$donor)
# -------------------------------------------

# Create colour palette for plots later.
# --------------------------------------
colour <- colour("vibrant")(7)
colour <- append("#DDAA33", colour) # Maximum size of chosen palette is 7 but we need 8, so add one that fits in.
colour <- colour[c(1, 2, 5, 3, 4, 7, 6, 8)] # Specify an order that provides better contrast.
names(colour) <- unique(sub("\\.", replacement = " ", x = experimental_design$condition))
# --------------------------------------

data <- make_se(data, columns = LFQ_columns, expdesign = experimental_design)
```

# Figure S2 A

Plot of the number of uniquely captured proteins per sample.

```{r}
plot_numbers(data) + theme(axis.text.x = element_text(size = 7)) + scale_x_discrete(labels = data$nice_names)
```

# Figure S2 B

Plot of the distribution of missing values throughout the samples.

```{r, fig.width = 12}
colnames(data) <- data$nice_names
plot_missval(data)
colnames(data) <- data$ID # Some DEP functions are incompatible with the format in `nice_names`, so revert back.
```

# Figure S3 C

Missing value proportion to log2 intensity chart, with line drawn at the MNAR cutoff point.
Only fraction 1 is shown here as a representative example, but the others can be trivially produced by removing `results = "hide"` and `fig.show = "hide"` in their code chunk when re-running this R Markdown.

```{r, results = "hide", fig.show = "hide"}
# Replace proteins missing entirely in a condition with minimum value per condition in random samples.
# Cache the object as operation can be lengthy.
# ----------------------------------------------------------------------------------------------------
rds <- file.path(cache_dir, "data_NA_replaced_by_fraction.rds")
if (file.exists(rds)) {
  data <- readRDS(rds)
} else {
  for (fraction in unique(data$condition)) {
    min <- min(assay(data)[ , which(data$condition == fraction)], na.rm = TRUE)
    replace <- which(is.na(rowMeans(assay(data)[ , which(data$condition == fraction)], na.rm = TRUE)))
    set.seed(1)
    col <- sample(which(data$condition == fraction), size = length(replace), replace = TRUE)
    for (i in seq_along(replace)) {
      assay(data)[replace[i], col[i]] <- min
    }
  }
  saveRDS(data, file = rds)
}
# ----------------------------------------------------------------------------------------------------

# Find intensity cutoff point at which MNAR becomes MAR by finding the inflection point of intensity where the
# proportion of proteins with missing values dramatically level off.
# We do this separately for each condition.
# ------------------------------------------------------------------------------------------------------------

# Custom version of `DEP::plot_detect` for producing a plot to find the intersection at which MNAR becomes MAR.
# -------------------------------------------------------------------------------------------------------------
plot_detect_custom <- function(se) {
  # Show error if inputs are not the required classes
  assertthat::assert_that(inherits(se, "SummarizedExperiment"))

  se_assay <- assay(se)
  # Show error if there are no missing values
  if(!any(is.na(se_assay))) {
    stop("No missing values in '", deparse(substitute(se)), "'",
         call. = FALSE)
  }

  # Get a long data.frame of the assay data annotated with sample info
  df <- se_assay %>%
    data.frame() %>%
    rownames_to_column() %>%
    tidyr::gather(ID, val, -rowname)

  # Get a summarized table with mean protein intensities and
  # indication whether the protein has missing values
  stat <- df %>%
    group_by(rowname) %>%
    summarize(mean = mean(val, na.rm = TRUE), missval = any(is.na(val)))

  # Calculate cumulative fraction
  cumsum <- stat %>%
    group_by(missval) %>%
    arrange(mean) %>%
    mutate(num = 1, cs = cumsum(num), cs_frac = cs/n())

  # Create a stacked probability density plot instead of the usual plots.
  # ---------------------------------------------------------------------
  color <- c("#74A9CF", "#045A8D")
  p <- ggplot(stat, aes(mean, ..count.., fill = missval, color = missval)) +
    geom_density(position = "fill") +
    scale_x_continuous(expression(log[2]~"Intensity"), expand = c(0, 0), n.breaks = 10) +
    scale_y_continuous("Relative proportion", labels = percent, expand = c(0, 0), n.breaks = 10) +
    theme_DEP1() +
    scale_color_manual("Missing values", values = color) +
    scale_fill_manual("Missing values", values = color)
  # ---------------------------------------------------------------------

  p
}
# -------------------------------------------------------------------------------------------------------------
```

```{r}
plot <- plot_detect_custom(data[ , which(data$condition == "Fraction.1")])
plot_data <- ggplot_build(plot)
F1_MNAR_cutoff <- 14.9
plot + geom_vline(xintercept = F1_MNAR_cutoff) + ggtitle("Fraction 1")
```

```{r, results = "hide", fig.show = "hide"}
# For brevity these plots are hidden with the chunk parameters `results = "hide"` and `fig.show = "hide"` and can be
# viewed by removing the parameter when re-running the R Markdown.
# ------------------------------------------------------------------------------------------------------------------
plot <- plot_detect_custom(data[ , which(data$condition == "Fraction.2")])
plot_data <- ggplot_build(plot)
F2_MNAR_cutoff <- 14.7
plot + geom_vline(xintercept = F2_MNAR_cutoff) + ggtitle("Fraction 2")

plot <- plot_detect_custom(data[ , which(data$condition == "Fraction.3")])
plot_data <- ggplot_build(plot)
F3_MNAR_cutoff <- 14.9
plot + geom_vline(xintercept = F3_MNAR_cutoff) + ggtitle("Fraction 3")

plot <- plot_detect_custom(data[ , which(data$condition == "Fraction.4")])
plot_data <- ggplot_build(plot)
F4_MNAR_cutoff <- 14.3
plot + geom_vline(xintercept = F4_MNAR_cutoff) + ggtitle("Fraction 4")

plot <- plot_detect_custom(data[ , which(data$condition == "Fraction.5")])
plot_data <- ggplot_build(plot)
F5_MNAR_cutoff <- 14.6
plot + geom_vline(xintercept = F5_MNAR_cutoff) + ggtitle("Fraction 5")

plot <- plot_detect_custom(data[ , which(data$condition == "Fraction.6")])
plot_data <- ggplot_build(plot)
F6_MNAR_cutoff <- 14.5
plot + geom_vline(xintercept = F6_MNAR_cutoff) + ggtitle("Fraction 6")

plot <- plot_detect_custom(data[ , which(data$condition == "Fraction.7")])
plot_data <- ggplot_build(plot)
F7_MNAR_cutoff <- 15.3
plot + geom_vline(xintercept = F7_MNAR_cutoff) + ggtitle("Fraction 7")

plot <- plot_detect_custom(data[ , which(data$condition == "Fraction.8")])
plot_data <- ggplot_build(plot)
F8_MNAR_cutoff <- 15.2
plot + geom_vline(xintercept = F8_MNAR_cutoff) + ggtitle("Fraction 8")
# ------------------------------------------------------------------------------------------------------------------
```

```{r, results = "hide", fig.show = "hide"}
# Order each condition by row means and select the last protein to be included as MNAR.
# We choose row means over medians because high expression outliers may be decent indication a protein is not MNAR.
# -----------------------------------------------------------------------------------------------------------------
F1_order <- order(rowMeans(assay(data)[ , which(data$condition == "Fraction.1")], na.rm = TRUE))
data <- data[F1_order, ]
F1_MNAR <- names(which(rowMeans(assay(data)[ , which(data$condition == "Fraction.1")], na.rm = TRUE) < F1_MNAR_cutoff))

F2_order <- order(rowMeans(assay(data)[ , which(data$condition == "Fraction.2")], na.rm = TRUE))
data <- data[F2_order, ]
F2_MNAR <- names(which(rowMeans(assay(data)[ , which(data$condition == "Fraction.2")], na.rm = TRUE) < F2_MNAR_cutoff))

F3_order <- order(rowMeans(assay(data)[ , which(data$condition == "Fraction.3")], na.rm = TRUE))
data <- data[F3_order, ]
F3_MNAR <- names(which(rowMeans(assay(data)[ , which(data$condition == "Fraction.3")], na.rm = TRUE) < F3_MNAR_cutoff))

F4_order <- order(rowMeans(assay(data)[ , which(data$condition == "Fraction.4")], na.rm = TRUE))
data <- data[F4_order, ]
F4_MNAR <- names(which(rowMeans(assay(data)[ , which(data$condition == "Fraction.4")], na.rm = TRUE) < F4_MNAR_cutoff))

F5_order <- order(rowMeans(assay(data)[ , which(data$condition == "Fraction.5")], na.rm = TRUE))
data <- data[F5_order, ]
F5_MNAR <- names(which(rowMeans(assay(data)[ , which(data$condition == "Fraction.5")], na.rm = TRUE) < F5_MNAR_cutoff))

F6_order <- order(rowMeans(assay(data)[ , which(data$condition == "Fraction.6")], na.rm = TRUE))
data <- data[F6_order, ]
F6_MNAR <- names(which(rowMeans(assay(data)[ , which(data$condition == "Fraction.6")], na.rm = TRUE) < F6_MNAR_cutoff))

F7_order <- order(rowMeans(assay(data)[ , which(data$condition == "Fraction.7")], na.rm = TRUE))
data <- data[F7_order, ]
F7_MNAR <- names(which(rowMeans(assay(data)[ , which(data$condition == "Fraction.7")], na.rm = TRUE) < F7_MNAR_cutoff))

F8_order <- order(rowMeans(assay(data)[ , which(data$condition == "Fraction.8")], na.rm = TRUE))
data <- data[F8_order, ]
F8_MNAR <- names(which(rowMeans(assay(data)[ , which(data$condition == "Fraction.8")], na.rm = TRUE) < F8_MNAR_cutoff))
# -----------------------------------------------------------------------------------------------------------------

# In each condition, remove MAR (non-MNAR) proteins where the majority are missing.
# Generally, we have found that MAR imputation with a majority of missing values leads to suspect imputation.
# MNAR imputation however, does not seem to suffer from this limitation, and in fact it is logical that MNAR proteins
# would have a high number of missing values.
# -------------------------------------------------------------------------------------------------------------------
F1_data <- data[ , which(data$condition == "Fraction.1")]
F1_data <- F1_data[rownames(F1_data) %notin% F1_MNAR, ]
missing_data <- assay(F1_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), yes = 0, no = 1)
discard <- which(rowSums(missing_data, TRUE) < 5)
if (length(discard) > 0) {
  F1_data <- F1_data[-discard, ]
}

F2_data <- data[ , which(data$condition == "Fraction.2")]
F2_data <- F2_data[rownames(F2_data) %notin% F2_MNAR, ]
missing_data <- assay(F2_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), yes = 0, no = 1)
discard <- which(rowSums(missing_data, TRUE) < 5)
if (length(discard) > 0) {
  F2_data <- F2_data[-discard, ]
}

F3_data <- data[ , which(data$condition == "Fraction.3")]
F3_data <- F3_data[rownames(F3_data) %notin% F3_MNAR, ]
missing_data <- assay(F3_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), yes = 0, no = 1)
discard <- which(rowSums(missing_data, TRUE) < 5)
if (length(discard) > 0) {
  F3_data <- F3_data[-discard, ]
}

F4_data <- data[ , which(data$condition == "Fraction.4")]
F4_data <- F4_data[rownames(F4_data) %notin% F4_MNAR, ]
missing_data <- assay(F4_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), yes = 0, no = 1)
discard <- which(rowSums(missing_data, TRUE) < 5)
if (length(discard) > 0) {
  F4_data <- F4_data[-discard, ]
}

F5_data <- data[ , which(data$condition == "Fraction.5")]
F5_data <- F5_data[rownames(F5_data) %notin% F5_MNAR, ]
missing_data <- assay(F5_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), yes = 0, no = 1)
discard <- which(rowSums(missing_data, TRUE) < 5)
if (length(discard) > 0) {
  F5_data <- F5_data[-discard, ]
}

F6_data <- data[ , which(data$condition == "Fraction.6")]
F6_data <- F6_data[rownames(F6_data) %notin% F6_MNAR, ]
missing_data <- assay(F6_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), yes = 0, no = 1)
discard <- which(rowSums(missing_data, TRUE) < 5)
if (length(discard) > 0) {
  F6_data <- F6_data[-discard, ]
}

F7_data <- data[ , which(data$condition == "Fraction.7")]
F7_data <- F7_data[rownames(F7_data) %notin% F7_MNAR, ]
missing_data <- assay(F7_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), yes = 0, no = 1)
discard <- which(rowSums(missing_data, TRUE) < 5)
if (length(discard) > 0) {
  F7_data <- F7_data[-discard, ]
}

F8_data <- data[ , which(data$condition == "Fraction.8")]
F8_data <- F8_data[rownames(F8_data) %notin% F8_MNAR, ]
missing_data <- assay(F8_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), yes = 0, no = 1)
discard <- which(rowSums(missing_data, TRUE) < 3) # Only 5 samples after removal of outliers, so lower threshold.
if (length(discard) > 0) {
  F8_data <- F8_data[-discard, ]
}
# -------------------------------------------------------------------------------------------------------------------

# In order to ensure that all conditions have MAR proteins with majority non-missing values, we perform the unions
# below.
# For example, out of the proteins that pass this QC in one condition, or have no missing values, we only keep those
# that pass this QC, have no missing values, or are MNAR in all other conditions as well.
# ------------------------------------------------------------------------------------------------------------------
F1_MAR <- rownames(F1_data)[rownames(F1_data) %in% F2_MNAR | rownames(F1_data) %in% rownames(F2_data)]
F1_MAR <- intersect(
  F1_MAR, rownames(F1_data)[rownames(F1_data) %in% F3_MNAR | rownames(F1_data) %in% rownames(F3_data)]
)
F1_MAR <- intersect(
  F1_MAR, rownames(F1_data)[rownames(F1_data) %in% F4_MNAR | rownames(F1_data) %in% rownames(F4_data)]
)
F1_MAR <- intersect(
  F1_MAR, rownames(F1_data)[rownames(F1_data) %in% F5_MNAR | rownames(F1_data) %in% rownames(F5_data)]
)
F1_MAR <- intersect(
  F1_MAR, rownames(F1_data)[rownames(F1_data) %in% F7_MNAR | rownames(F1_data) %in% rownames(F7_data)]
)
F1_MAR <- intersect(
  F1_MAR, rownames(F1_data)[rownames(F1_data) %in% F8_MNAR | rownames(F1_data) %in% rownames(F8_data)]
)

F2_MAR <- rownames(F2_data)[rownames(F2_data) %in% F1_MNAR | rownames(F2_data) %in% rownames(F1_data)]
F2_MAR <- intersect(
  F2_MAR, rownames(F2_data)[rownames(F2_data) %in% F3_MNAR | rownames(F2_data) %in% rownames(F3_data)]
)
F2_MAR <- intersect(
  F2_MAR, rownames(F2_data)[rownames(F2_data) %in% F4_MNAR | rownames(F2_data) %in% rownames(F4_data)]
)
F2_MAR <- intersect(
  F2_MAR, rownames(F2_data)[rownames(F2_data) %in% F5_MNAR | rownames(F2_data) %in% rownames(F5_data)]
)
F2_MAR <- intersect(
  F2_MAR, rownames(F2_data)[rownames(F2_data) %in% F6_MNAR | rownames(F2_data) %in% rownames(F6_data)]
)
F2_MAR <- intersect(
  F2_MAR, rownames(F2_data)[rownames(F2_data) %in% F7_MNAR | rownames(F2_data) %in% rownames(F7_data)]
)
F2_MAR <- intersect(
  F2_MAR, rownames(F2_data)[rownames(F2_data) %in% F8_MNAR | rownames(F2_data) %in% rownames(F8_data)]
)

F3_MAR <- rownames(F3_data)[rownames(F3_data) %in% F1_MNAR | rownames(F3_data) %in% rownames(F1_data)]
F3_MAR <- intersect(
  F3_MAR, rownames(F3_data)[rownames(F3_data) %in% F2_MNAR | rownames(F3_data) %in% rownames(F2_data)]
)
F3_MAR <- intersect(
  F3_MAR, rownames(F3_data)[rownames(F3_data) %in% F4_MNAR | rownames(F3_data) %in% rownames(F4_data)]
)
F3_MAR <- intersect(
  F3_MAR, rownames(F3_data)[rownames(F3_data) %in% F5_MNAR | rownames(F3_data) %in% rownames(F5_data)]
)
F3_MAR <- intersect(
  F3_MAR, rownames(F3_data)[rownames(F3_data) %in% F6_MNAR | rownames(F3_data) %in% rownames(F6_data)]
)
F3_MAR <- intersect(
  F3_MAR, rownames(F3_data)[rownames(F3_data) %in% F7_MNAR | rownames(F3_data) %in% rownames(F7_data)]
)
F3_MAR <- intersect(
  F3_MAR, rownames(F3_data)[rownames(F3_data) %in% F8_MNAR | rownames(F3_data) %in% rownames(F8_data)]
)

F4_MAR <- rownames(F4_data)[rownames(F4_data) %in% F1_MNAR | rownames(F4_data) %in% rownames(F1_data)]
F4_MAR <- intersect(
  F4_MAR, rownames(F4_data)[rownames(F4_data) %in% F2_MNAR | rownames(F4_data) %in% rownames(F2_data)]
)
F4_MAR <- intersect(
  F4_MAR, rownames(F4_data)[rownames(F4_data) %in% F3_MNAR | rownames(F4_data) %in% rownames(F3_data)]
)
F4_MAR <- intersect(
  F4_MAR, rownames(F4_data)[rownames(F4_data) %in% F5_MNAR | rownames(F4_data) %in% rownames(F5_data)]
)
F4_MAR <- intersect(
  F4_MAR, rownames(F4_data)[rownames(F4_data) %in% F6_MNAR | rownames(F4_data) %in% rownames(F6_data)]
)
F4_MAR <- intersect(
  F4_MAR, rownames(F4_data)[rownames(F4_data) %in% F7_MNAR | rownames(F4_data) %in% rownames(F7_data)]
)
F4_MAR <- intersect(
  F4_MAR, rownames(F4_data)[rownames(F4_data) %in% F8_MNAR | rownames(F4_data) %in% rownames(F8_data)]
)

F5_MAR <- rownames(F5_data)[rownames(F5_data) %in% F1_MNAR | rownames(F5_data) %in% rownames(F1_data)]
F5_MAR <- intersect(
  F5_MAR, rownames(F5_data)[rownames(F5_data) %in% F2_MNAR | rownames(F5_data) %in% rownames(F2_data)]
)
F5_MAR <- intersect(
  F5_MAR, rownames(F5_data)[rownames(F5_data) %in% F3_MNAR | rownames(F5_data) %in% rownames(F3_data)]
)
F5_MAR <- intersect(
  F5_MAR, rownames(F5_data)[rownames(F5_data) %in% F4_MNAR | rownames(F5_data) %in% rownames(F4_data)]
)
F5_MAR <- intersect(
  F5_MAR, rownames(F5_data)[rownames(F5_data) %in% F6_MNAR | rownames(F5_data) %in% rownames(F6_data)]
)
F5_MAR <- intersect(
  F5_MAR, rownames(F5_data)[rownames(F5_data) %in% F7_MNAR | rownames(F5_data) %in% rownames(F7_data)]
)
F5_MAR <- intersect(
  F5_MAR, rownames(F5_data)[rownames(F5_data) %in% F8_MNAR | rownames(F5_data) %in% rownames(F8_data)]
)

F6_MAR <- rownames(F6_data)[rownames(F6_data) %in% F1_MNAR | rownames(F6_data) %in% rownames(F1_data)]
F6_MAR <- intersect(
  F6_MAR, rownames(F6_data)[rownames(F6_data) %in% F2_MNAR | rownames(F6_data) %in% rownames(F2_data)]
)
F6_MAR <- intersect(
  F6_MAR, rownames(F6_data)[rownames(F6_data) %in% F3_MNAR | rownames(F6_data) %in% rownames(F3_data)]
)
F6_MAR <- intersect(
  F6_MAR, rownames(F6_data)[rownames(F6_data) %in% F4_MNAR | rownames(F6_data) %in% rownames(F4_data)]
)
F6_MAR <- intersect(
  F6_MAR, rownames(F6_data)[rownames(F6_data) %in% F5_MNAR | rownames(F6_data) %in% rownames(F5_data)]
)
F6_MAR <- intersect(
  F6_MAR, rownames(F6_data)[rownames(F6_data) %in% F7_MNAR | rownames(F6_data) %in% rownames(F7_data)]
)
F6_MAR <- intersect(
  F6_MAR, rownames(F6_data)[rownames(F6_data) %in% F8_MNAR | rownames(F6_data) %in% rownames(F8_data)]
)

F7_MAR <- rownames(F7_data)[rownames(F7_data) %in% F1_MNAR | rownames(F7_data) %in% rownames(F1_data)]
F7_MAR <- intersect(
  F7_MAR, rownames(F7_data)[rownames(F7_data) %in% F2_MNAR | rownames(F7_data) %in% rownames(F2_data)]
)
F7_MAR <- intersect(
  F7_MAR, rownames(F7_data)[rownames(F7_data) %in% F3_MNAR | rownames(F7_data) %in% rownames(F3_data)]
)
F7_MAR <- intersect(
  F7_MAR, rownames(F7_data)[rownames(F7_data) %in% F4_MNAR | rownames(F7_data) %in% rownames(F4_data)]
)
F7_MAR <- intersect(
  F7_MAR, rownames(F7_data)[rownames(F7_data) %in% F5_MNAR | rownames(F7_data) %in% rownames(F5_data)]
)
F7_MAR <- intersect(
  F7_MAR, rownames(F7_data)[rownames(F7_data) %in% F6_MNAR | rownames(F7_data) %in% rownames(F6_data)]
)
F7_MAR <- intersect(
  F7_MAR, rownames(F7_data)[rownames(F7_data) %in% F8_MNAR | rownames(F7_data) %in% rownames(F8_data)]
)

F8_MAR <- rownames(F8_data)[rownames(F8_data) %in% F1_MNAR | rownames(F8_data) %in% rownames(F1_data)]
F8_MAR <- intersect(
  F8_MAR, rownames(F8_data)[rownames(F8_data) %in% F2_MNAR | rownames(F8_data) %in% rownames(F2_data)]
)
F8_MAR <- intersect(
  F8_MAR, rownames(F8_data)[rownames(F8_data) %in% F3_MNAR | rownames(F8_data) %in% rownames(F3_data)]
)
F8_MAR <- intersect(
  F8_MAR, rownames(F8_data)[rownames(F8_data) %in% F4_MNAR | rownames(F8_data) %in% rownames(F4_data)]
)
F8_MAR <- intersect(
  F8_MAR, rownames(F8_data)[rownames(F8_data) %in% F5_MNAR | rownames(F8_data) %in% rownames(F5_data)]
)
F8_MAR <- intersect(
  F8_MAR, rownames(F8_data)[rownames(F8_data) %in% F6_MNAR | rownames(F8_data) %in% rownames(F6_data)]
)
F8_MAR <- intersect(
  F8_MAR, rownames(F8_data)[rownames(F8_data) %in% F7_MNAR | rownames(F8_data) %in% rownames(F7_data)]
)

rm(F1_data, F2_data, F3_data, F4_data, F5_data, F6_data, F7_data, F8_data)
MAR <- unique(append(F1_MAR, c(F2_MAR, F3_MAR, F4_MAR, F5_MAR, F6_MAR, F7_MAR, F8_MAR)))

F1_MNAR_passQC <- F1_MNAR[F1_MNAR %in% F2_MAR | F1_MNAR %in% F2_MNAR]
F1_MNAR_passQC <- intersect(F1_MNAR_passQC, F1_MNAR[F1_MNAR %in% F3_MAR | F1_MNAR %in% F3_MNAR])
F1_MNAR_passQC <- intersect(F1_MNAR_passQC, F1_MNAR[F1_MNAR %in% F4_MAR | F1_MNAR %in% F4_MNAR])
F1_MNAR_passQC <- intersect(F1_MNAR_passQC, F1_MNAR[F1_MNAR %in% F5_MAR | F1_MNAR %in% F5_MNAR])
F1_MNAR_passQC <- intersect(F1_MNAR_passQC, F1_MNAR[F1_MNAR %in% F6_MAR | F1_MNAR %in% F6_MNAR])
F1_MNAR_passQC <- intersect(F1_MNAR_passQC, F1_MNAR[F1_MNAR %in% F7_MAR | F1_MNAR %in% F7_MNAR])
F1_MNAR_passQC <- intersect(F1_MNAR_passQC, F1_MNAR[F1_MNAR %in% F8_MAR | F1_MNAR %in% F8_MNAR])

F2_MNAR_passQC <- F2_MNAR[F2_MNAR %in% F1_MAR | F2_MNAR %in% F1_MNAR]
F2_MNAR_passQC <- intersect(F2_MNAR_passQC, F2_MNAR[F2_MNAR %in% F3_MAR | F2_MNAR %in% F3_MNAR])
F2_MNAR_passQC <- intersect(F2_MNAR_passQC, F2_MNAR[F2_MNAR %in% F4_MAR | F2_MNAR %in% F4_MNAR])
F2_MNAR_passQC <- intersect(F2_MNAR_passQC, F2_MNAR[F2_MNAR %in% F5_MAR | F2_MNAR %in% F5_MNAR])
F2_MNAR_passQC <- intersect(F2_MNAR_passQC, F2_MNAR[F2_MNAR %in% F6_MAR | F2_MNAR %in% F6_MNAR])
F2_MNAR_passQC <- intersect(F2_MNAR_passQC, F2_MNAR[F2_MNAR %in% F7_MAR | F2_MNAR %in% F7_MNAR])
F2_MNAR_passQC <- intersect(F2_MNAR_passQC, F2_MNAR[F2_MNAR %in% F8_MAR | F2_MNAR %in% F8_MNAR])

F3_MNAR_passQC <- F3_MNAR[F3_MNAR %in% F1_MAR | F3_MNAR %in% F1_MNAR]
F3_MNAR_passQC <- intersect(F3_MNAR_passQC, F3_MNAR[F3_MNAR %in% F2_MAR | F3_MNAR %in% F2_MNAR])
F3_MNAR_passQC <- intersect(F3_MNAR_passQC, F3_MNAR[F3_MNAR %in% F4_MAR | F3_MNAR %in% F4_MNAR])
F3_MNAR_passQC <- intersect(F3_MNAR_passQC, F3_MNAR[F3_MNAR %in% F5_MAR | F3_MNAR %in% F5_MNAR])
F3_MNAR_passQC <- intersect(F3_MNAR_passQC, F3_MNAR[F3_MNAR %in% F6_MAR | F3_MNAR %in% F6_MNAR])
F3_MNAR_passQC <- intersect(F3_MNAR_passQC, F3_MNAR[F3_MNAR %in% F7_MAR | F3_MNAR %in% F7_MNAR])
F3_MNAR_passQC <- intersect(F3_MNAR_passQC, F3_MNAR[F3_MNAR %in% F8_MAR | F3_MNAR %in% F8_MNAR])

F4_MNAR_passQC <- F4_MNAR[F4_MNAR %in% F1_MAR | F4_MNAR %in% F1_MNAR]
F4_MNAR_passQC <- intersect(F4_MNAR_passQC, F4_MNAR[F4_MNAR %in% F2_MAR | F4_MNAR %in% F2_MNAR])
F4_MNAR_passQC <- intersect(F4_MNAR_passQC, F4_MNAR[F4_MNAR %in% F3_MAR | F4_MNAR %in% F3_MNAR])
F4_MNAR_passQC <- intersect(F4_MNAR_passQC, F4_MNAR[F4_MNAR %in% F5_MAR | F4_MNAR %in% F5_MNAR])
F4_MNAR_passQC <- intersect(F4_MNAR_passQC, F4_MNAR[F4_MNAR %in% F6_MAR | F4_MNAR %in% F6_MNAR])
F4_MNAR_passQC <- intersect(F4_MNAR_passQC, F4_MNAR[F4_MNAR %in% F7_MAR | F4_MNAR %in% F7_MNAR])
F4_MNAR_passQC <- intersect(F4_MNAR_passQC, F4_MNAR[F4_MNAR %in% F8_MAR | F4_MNAR %in% F8_MNAR])

F5_MNAR_passQC <- F5_MNAR[F5_MNAR %in% F1_MAR | F5_MNAR %in% F1_MNAR]
F5_MNAR_passQC <- intersect(F5_MNAR_passQC, F5_MNAR[F5_MNAR %in% F2_MAR | F5_MNAR %in% F2_MNAR])
F5_MNAR_passQC <- intersect(F5_MNAR_passQC, F5_MNAR[F5_MNAR %in% F3_MAR | F5_MNAR %in% F3_MNAR])
F5_MNAR_passQC <- intersect(F5_MNAR_passQC, F5_MNAR[F5_MNAR %in% F4_MAR | F5_MNAR %in% F4_MNAR])
F5_MNAR_passQC <- intersect(F5_MNAR_passQC, F5_MNAR[F5_MNAR %in% F6_MAR | F5_MNAR %in% F6_MNAR])
F5_MNAR_passQC <- intersect(F5_MNAR_passQC, F5_MNAR[F5_MNAR %in% F7_MAR | F5_MNAR %in% F7_MNAR])
F5_MNAR_passQC <- intersect(F5_MNAR_passQC, F5_MNAR[F5_MNAR %in% F8_MAR | F5_MNAR %in% F8_MNAR])

F6_MNAR_passQC <- F6_MNAR[F6_MNAR %in% F1_MAR | F6_MNAR %in% F1_MNAR]
F6_MNAR_passQC <- intersect(F6_MNAR_passQC, F6_MNAR[F6_MNAR %in% F2_MAR | F6_MNAR %in% F2_MNAR])
F6_MNAR_passQC <- intersect(F6_MNAR_passQC, F6_MNAR[F6_MNAR %in% F3_MAR | F6_MNAR %in% F3_MNAR])
F6_MNAR_passQC <- intersect(F6_MNAR_passQC, F6_MNAR[F6_MNAR %in% F4_MAR | F6_MNAR %in% F4_MNAR])
F6_MNAR_passQC <- intersect(F6_MNAR_passQC, F6_MNAR[F6_MNAR %in% F5_MAR | F6_MNAR %in% F5_MNAR])
F6_MNAR_passQC <- intersect(F6_MNAR_passQC, F6_MNAR[F6_MNAR %in% F7_MAR | F6_MNAR %in% F7_MNAR])
F6_MNAR_passQC <- intersect(F6_MNAR_passQC, F6_MNAR[F6_MNAR %in% F8_MAR | F6_MNAR %in% F8_MNAR])

F7_MNAR_passQC <- F7_MNAR[F7_MNAR %in% F1_MAR | F7_MNAR %in% F1_MNAR]
F7_MNAR_passQC <- intersect(F7_MNAR_passQC, F7_MNAR[F7_MNAR %in% F2_MAR | F7_MNAR %in% F2_MNAR])
F7_MNAR_passQC <- intersect(F7_MNAR_passQC, F7_MNAR[F7_MNAR %in% F3_MAR | F7_MNAR %in% F3_MNAR])
F7_MNAR_passQC <- intersect(F7_MNAR_passQC, F7_MNAR[F7_MNAR %in% F4_MAR | F7_MNAR %in% F4_MNAR])
F7_MNAR_passQC <- intersect(F7_MNAR_passQC, F7_MNAR[F7_MNAR %in% F5_MAR | F7_MNAR %in% F5_MNAR])
F7_MNAR_passQC <- intersect(F7_MNAR_passQC, F7_MNAR[F7_MNAR %in% F6_MAR | F7_MNAR %in% F6_MNAR])
F7_MNAR_passQC <- intersect(F7_MNAR_passQC, F7_MNAR[F7_MNAR %in% F8_MAR | F7_MNAR %in% F8_MNAR])

F8_MNAR_passQC <- F8_MNAR[F8_MNAR %in% F1_MAR | F8_MNAR %in% F1_MNAR]
F8_MNAR_passQC <- intersect(F8_MNAR_passQC, F8_MNAR[F8_MNAR %in% F2_MAR | F8_MNAR %in% F2_MNAR])
F8_MNAR_passQC <- intersect(F8_MNAR_passQC, F8_MNAR[F8_MNAR %in% F3_MAR | F8_MNAR %in% F3_MNAR])
F8_MNAR_passQC <- intersect(F8_MNAR_passQC, F8_MNAR[F8_MNAR %in% F4_MAR | F8_MNAR %in% F4_MNAR])
F8_MNAR_passQC <- intersect(F8_MNAR_passQC, F8_MNAR[F8_MNAR %in% F5_MAR | F8_MNAR %in% F5_MNAR])
F8_MNAR_passQC <- intersect(F8_MNAR_passQC, F8_MNAR[F8_MNAR %in% F6_MAR | F8_MNAR %in% F6_MNAR])
F8_MNAR_passQC <- intersect(F8_MNAR_passQC, F8_MNAR[F8_MNAR %in% F7_MAR | F8_MNAR %in% F7_MNAR])

MNAR <- unique(
  append(
    F1_MNAR_passQC,
    c(F2_MNAR_passQC, F3_MNAR_passQC, F4_MNAR_passQC, F5_MNAR_passQC, F6_MNAR_passQC, F7_MNAR_passQC, F8_MNAR_passQC)
  )
)
# ------------------------------------------------------------------------------------------------------------------

# We join MAR and MNAR lists and subset the data.
# -----------------------------------------------
keep <- unique(append(MAR, MNAR))
data <- data[rownames(data) %in% keep, ]
data <- data[sort(rownames(data)), ]
# -----------------------------------------------

data <- normalize_vsn(data) # Normalise using VSN.

# The main imputation code.
# -------------------------
impute1 <- data[ , which(data$condition == "Fraction.1")]
impute_vector <- rownames(impute1) %in% F1_MNAR
set.seed(1)
impute1 <- impute(impute1, fun = "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")

impute2 <- data[ , which(data$condition == "Fraction.2")]
impute_vector <- rownames(impute2) %in% F2_MNAR
set.seed(1)
impute2 <- impute(impute2, fun = "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")

impute3 <- data[ , which(data$condition == "Fraction.3")]
impute_vector <- rownames(impute3) %in% F3_MNAR
set.seed(1)
impute3 <- impute(impute3, fun = "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")

impute4 <- data[ , which(data$condition == "Fraction.4")]
impute_vector <- rownames(impute4) %in% F4_MNAR
set.seed(1)
impute4 <- impute(impute4, fun = "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")

impute5 <- data[ , which(data$condition == "Fraction.5")]
impute_vector <- rownames(impute5) %in% F5_MNAR
set.seed(1)
impute5 <- impute(impute5, fun = "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")

impute6 <- data[ , which(data$condition == "Fraction.6")]
impute_vector <- rownames(impute6) %in% F6_MNAR
set.seed(1)
impute6 <- impute(impute6, fun = "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")

impute7 <- data[ , which(data$condition == "Fraction.7")]
impute_vector <- rownames(impute7) %in% F7_MNAR
set.seed(1)
impute7 <- impute(impute7, fun = "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")

impute8 <- data[ , which(data$condition == "Fraction.8")]
impute_vector <- rownames(impute8) %in% F8_MNAR
set.seed(1)
impute8 <- impute(impute8, fun = "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")
# -------------------------

# Move imputed data to main object and clean up.
# ----------------------------------------------
assay(data, withDimnames = FALSE) <- cbind(
  assay(impute1), assay(impute2), assay(impute3), assay(impute4),
  assay(impute5), assay(impute6), assay(impute7), assay(impute8)
)
rm(impute1, impute2, impute3, impute4, impute5, impute6, impute7, impute8)
# ----------------------------------------------
```

# Figure 1 B

Principal component analysis (PCA) of the final imputed dataset.

```{r}
# Perform PCA and organise results.
# ---------------------------------
pca <- prcomp(t(assay(data))) # Use the transpose because PCA assumes rows are observations and columns are variables.
df <- as.data.frame(predict(pca)[ , 1:2]) # Extract the first two PCs.
df$Fraction <- sub("\\.", replacement = " ", x = data$condition)
df$Donor <- data$donor
summary <- summary(pca)$importance # Extract variance explained.
# ---------------------------------

# Plot the first two PCs.
# Ellipses are drawn for each fraction at the 68% CI, which approximately represent all values that lie within one
# standard deviation from the mean, following the 68-95-99.7 rule.
# ----------------------------------------------------------------------------------------------------------------
ggplot(df, aes(PC1, PC2, color = Fraction)) +
  geom_point(aes(shape = Donor), size = 2, stroke = 1) +
  theme_bw() +
  geom_polygon(stat = "ellipse", aes(fill = Fraction), alpha = 0.05, level = 0.68, type = "norm") +
  labs(
    x = paste0("PC1: ", round(summary[2, 1] * 100, digits = 1), "% of Variance Explained"),
    y = paste0("PC2: ", round(summary[2, 2] * 100, digits = 1), "% of Variance Explained")
  ) +
  scale_shape_manual(values = seq_along(df$Donor)) +
  scale_fill_manual(values = colour) +
  scale_colour_manual(values = colour) +
  theme(axis.title = element_text(size = 16))
# ----------------------------------------------------------------------------------------------------------------
```

# Supplementary Table 1 {.tabset}

Tabs containing tables of differentially expressed proteins (DEPs) for each fraction group (F1_3, F4_6, and F7_8) compared to all other fraction groups.
limma was used with default parameters except for multiple testing correction adjustment for all pairwise comparisons using the "global" method.
The adjusted p-value cutoff was set to the default 0.05 value.
Statistics shown are described in the limma documentation:

> This function writes a delimited text file containing for each gene (1) the average log2-intensity (AveExpr), (2) the coefficients or contrasts (log2-fold-changes, Coef), (3) moderated t-statistics, (4) t-statistic P-values, (5) F-statistic if available, (6) F-statistic P-values if available, (7) decideTests results if available and (8) gene names and annotation.

```{r, results = "hide", fig.show = "hide"}
# Apply limma for all pairwise comparisons as described.
# ------------------------------------------------------
limma_design <- model.matrix(~ 0 + experimental_design$groups)
colnames(limma_design) <- unique(experimental_design$groups)
contrast_mat <- makeContrasts(F1_3-F4_6, F1_3-F7_8, F4_6-F7_8, levels = limma_design)

fit <- lmFit(assay(data), design = limma_design)
cont_fit <- eBayes(contrasts.fit(fit, contrasts = contrast_mat))
tests <- decideTests(cont_fit, method = "global")
# ------------------------------------------------------

# The only way to get a full stats table as described is to write it out as a TSV then read it back in.
# -----------------------------------------------------------------------------------------------------
write.fit(
  cont_fit, results = tests, file = file.path(cache_dir, "results.tsv"),
  adjust = "BH", method = "global", F.adjust = "BH"
)
results <- read.delim(file.path(cache_dir, "results.tsv"))
# -----------------------------------------------------------------------------------------------------

# Clean up table and sort by adjusted F p-value.
# ----------------------------------------------
rownames(results) <- results$X
results <- results[ , -1]
results <- results[order(results$F.p.value.adj), ]
# ----------------------------------------------

# Subset stats table to highlight specific significant comparison combinations.
# For example, `F1_3` describe terms that are differentially expressed in `F1_3`, compared to both `F4_6` and `F7_8`.
# -------------------------------------------------------------------------------------------------------------------
tests_up <- tests[
  tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 0 |
    tests[ , 1] == 1 & tests[ , 2] == 0 & tests[ , 3] == 0 |
    tests[ , 1] == 0 & tests[ , 2] == 1 & tests[ , 3] == 0,
]
F1_3 <- results[rownames(results) %in% rownames(tests_up), ]

tests_up <- tests[
  tests[ , 1] == -1 & tests[ , 3] == 1 & tests[ , 2] == 0 |
    tests[ , 1] == -1 & tests[ , 3] == 0 & tests[ , 2] == 0 |
    tests[ , 1] == 0 & tests[ , 3] == 1 & tests[ , 2] == 0,
]
F4_6 <- results[rownames(results) %in% rownames(tests_up), ]

tests_up <- tests[
  tests[ , 2] == -1 & tests[ , 3] == -1 & tests[ , 1] == 0 |
    tests[ , 2] == -1 & tests[ , 3] == 0 & tests[ , 1] == 0 |
    tests[ , 2] == 0 & tests[ , 3] == -1 & tests[ , 1] == 0,
]
F7_8 <- results[rownames(results) %in% rownames(tests_up), ]
# -------------------------------------------------------------------------------------------------------------------
```

## F1_3

```{r}
datatable_download(F1_3) # Custom version of `DT::datatable`, see top of file under "Define functions" comment.
```

## F4_6

```{r}
datatable_download(F4_6) # Custom version of `DT::datatable`, see top of file under "Define functions" comment.
```

## F7_8

```{r}
datatable_download(F7_8) # Custom version of `DT::datatable`, see top of file under "Define functions" comment.
```

# Supplementary Table 2 {.tabset}

Tables containing the same comparisons as Supplementary Table 1 but for gene set enrichment (GSE) of Gene Ontology (GO) terms using the ssGSEA algorithm from GSVA combined with limma.
ssGSEA was shown to have similar performance to the default GSVA method, but we find it more versatile for having an option to turn off min-max scaling, allowing one to compare GSE across gene sets and not just samples.
Furthermore, tools such as limma are generally used with unscaled data.
We use limma for significance testing, using default parameters as suggested by GSVA developers and as in the DEP analysis, except again using the "global" method for multiple testing correction.
This time we also set the adjusted p-value cutoff to $5^{-4}$ (0.0005), chosen to select no more than about 500 gene sets total after combining gene sets uniquely enriched in F1_3, F4_6 or F7_8.

```{r, results = "hide", fig.show = "hide"}
# Filter GO terms for redundancy to improve interpretation and reduce multiple testing burden.
# Cache the object as operation can be lengthy.
# GO terms were downloaded from g:Profiler (https://biit.cs.ut.ee/gprofiler/gost) and a set combining BP, MF, and CC
# terms was created.
# ------------------------------------------------------------------------------------------------------------------
rds <- file.path(cache_dir, "filtered_GO_all_ENSG.rds")
if (file.exists(rds)) {
  gene_sets <- readRDS(rds)
} else {
  gene_sets <- getGmt(file.path(data_dir, "gene-sets", "gprofiler_hsapiens.ENSG", "hsapiens.GO.all.ENSG.gmt"))

  keep <- filterGeneSets(gene_sets, min.sz = 5, max.sz = 50) # Only keep terms with between 5 and 50 genes.
  gene_sets <- gene_sets[names(gene_sets) %in% names(keep)]

  # Restructure GeneSetCollection for easier analysis.
  # --------------------------------------------------
  for (i in seq(length(gene_sets@.Data))) {
    go_id <- gene_sets[[i]]@setName
    suppressWarnings(gene_sets[[i]]@setName <- gene_sets[[i]]@shortDescription)
    suppressWarnings(gene_sets[[i]]@shortDescription <- go_id)
  }
  # --------------------------------------------------

  # Remove terms with directionality as they can often be uninformative/inaccurate.
  # -------------------------------------------------------------------------------
  remove <- grep("positive regulation of", x = names(gene_sets))
  if (length(remove) > 0) {
    gene_sets <- gene_sets[-remove]
  }
  remove <- grep("negative regulation of", x = names(gene_sets))
  if (length(remove) > 0) {
    gene_sets <- gene_sets[-remove]
  }
  remove <- grep("regulation of", x = names(gene_sets))
  if (length(remove) > 0) {
    gene_sets <- gene_sets[-remove]
  }
  remove <- grep("downregulation of", x = names(gene_sets))
  if (length(remove) > 0) {
    gene_sets <- gene_sets[-remove]
  }
  remove <- grep("inhibition of", x = names(gene_sets))
  if (length(remove) > 0) {
    gene_sets <- gene_sets[-remove]
  }
  remove <- grep("termination of", x = names(gene_sets))
  if (length(remove) > 0) {
    gene_sets <- gene_sets[-remove]
  }
  remove <- grep("activation of", x = names(gene_sets))
  if (length(remove) > 0) {
    gene_sets <- gene_sets[-remove]
  }
  remove <- grep("maintenance of", x = names(gene_sets))
  if (length(remove) > 0) {
    gene_sets <- gene_sets[-remove]
  }
  remove <- grep("upregulation of", x = names(gene_sets))
  if (length(remove) > 0) {
    gene_sets <- gene_sets[-remove]
  }
  # -------------------------------------------------------------------------------

  saveRDS(gene_sets, file = rds)
}
# ------------------------------------------------------------------------------------------------------------------

# The gene sets use Ensembl IDs, which are more standardised than gene symbols.
# Since the data does not contain Ensembl IDs, we add them below.
# This process involves considerable bookkeeping to handle imperfect matching of Ensembl IDs and gene symbols.
# Several objects are cached as operation can be lengthy.
# ------------------------------------------------------------------------------------------------------------
rds <- file.path(cache_dir, "gene_anno.rds")
rds2 <- file.path(cache_dir, "new_mat.rds")
rds3 <- file.path(cache_dir, "gene_sets.rds")
if (file.exists(rds)) {
  gene_anno <- readRDS(rds)
  new_mat <- readRDS(rds2)
  gene_sets <- readRDS(rds3)
} else {

  # Retrieve Ensembl IDs.
  # ---------------------
  mart <- useEnsembl("ensembl", dataset = "hsapiens_gene_ensembl")
  attributes <- c("external_gene_name", "ensembl_gene_id")
  gene_anno <- getBM(attributes, filters = "external_gene_name", values = rownames(data), mart = mart)
  # ---------------------

  # Intersect Ensembl IDs from data with those from gene sets, making sure gene sets still fall within 5 and 50 genes.
  # ------------------------------------------------------------------------------------------------------------------
  gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% unique(unlist(geneIds(gene_sets))), ]

  tmp <- lapply(
    geneIds(gene_sets), FUN = function(x, y) na.omit(fastmatch::fmatch(x, table = y)), gene_anno$ensembl_gene_id
  )
  tmp <- filterGeneSets(tmp, 5, 50)
  gene_sets <- gene_sets[names(gene_sets) %in% names(tmp)]
  # ------------------------------------------------------------------------------------------------------------------

  # Modified version of `GSVA::computeGeneSetsOverlap` for calculating the overlap between gene sets.
  # The default implementation can lead to large overlap scores for small gene sets because for each gene set,
  # it divides the number of overlapping genes with the size of the smaller gene set in the comparison.
  # An arguably more accurate picture of overlap is to divide by the larger gene set instead, requiring that a large
  # overlap score be achieved only when gene sets are similar in size.
  # It also ensures that perfect overlaps equalling 1 are only found when gene sets are identical, which is very helpful
  # when one wants to remove these kind of duplicates.
  # --------------------------------------------------------------------------------------------------------------------
  computeGeneSetsOverlapMax <- function(gSets, uniqGenes, min.sz=1, max.sz=Inf) {
    ## gSetsMembershipMatrix should be a (genes x gene-sets) incidence matrix

    gSetsMembershipMatrix <- incidence(gSets)
    gSetsMembershipMatrix <- t(gSetsMembershipMatrix[, colnames(gSetsMembershipMatrix) %in% uniqGenes])

    lenGsets <- colSums(gSetsMembershipMatrix)

    szFilterMask <- lenGsets >= max(1, min.sz) & lenGsets <= max.sz
    if (!any(szFilterMask))
      stop("No gene set meets the minimum and maximum size filter\n")

    gSetsMembershipMatrix <- gSetsMembershipMatrix[, szFilterMask]
    lenGsets <- lenGsets[szFilterMask]

    totalGsets <- ncol(gSetsMembershipMatrix)

    M <- t(gSetsMembershipMatrix) %*% gSetsMembershipMatrix

    M1 <- matrix(lenGsets, nrow=totalGsets, ncol=totalGsets,
                 dimnames=list(colnames(gSetsMembershipMatrix), colnames(gSetsMembershipMatrix)))
    M2 <- t(M1)
    M.max <- matrix(0, nrow=totalGsets, ncol=totalGsets)
    M.max[M1 > M2] <- M1[M1 > M2]
    M.max[M2 >= M1] <- M2[M2 >= M1]
    overlapMatrix <- M / M.max

    return (overlapMatrix)
  }
  # --------------------------------------------------------------------------------------------------------------------

  # Order gene sets by how much they overlap with all other gene sets.
  # When removing gene sets based on overlap with other another gene set, this creates a preference to keep the more
  # general gene set i.e. the one that overlaps most with all other gene sets.
  # ----------------------------------------------------------------------------------------------------------------
  overlap <- computeGeneSetsOverlapMax(gene_sets, unique(unlist(geneIds(gene_sets))))
  tmp <- rowSums(overlap)
  tmp <- tmp[order(tmp, decreasing = TRUE)]
  gene_sets_sorted <- gene_sets[match(names(tmp), table = names(gene_sets))]
  # ----------------------------------------------------------------------------------------------------------------

  # Keep gene sets with less than 25% overlap with any other gene set.
  # ------------------------------------------------------------------
  overlap <- computeGeneSetsOverlapMax(gene_sets_sorted, uniqGenes = unique(unlist(geneIds(gene_sets_sorted))))
  overlap[upper.tri(overlap)] <- 0 # Look at overlap scores in rows only, which requires filling the upper tri with 0s.
  diag(overlap) <- 0 # The diagonal should also be filled with 0, otherwise everything would be removed.
  keep <- apply(overlap, MARGIN = 1, FUN = max) # Find the max overlap score for each row.
  keep <- keep[keep < 0.25]
  gene_sets <- gene_sets[names(gene_sets) %in% names(keep)]
  # ------------------------------------------------------------------

  gene_anno <- gene_anno[gene_anno$ensembl_gene_id %in% unique(unlist(geneIds(gene_sets))), ] # Subset to new gene sets.

  # It's possible for a gene symbol to match multiple Ensembl IDs.
  # We deal with these duplicate gene symbols by appending them with `-alt`.
  # This requires a new matrix to be made for the dataset.
  # ------------------------------------------------------------------------
  dup <- gene_anno[duplicated(gene_anno$external_gene_name), ]
  if (nrow(dup) > 0) {
    for (i in seq(nrow(dup))) {
      for (j in seq(nrow(gene_anno))) {
        if (dup$ensembl_gene_id[i] == gene_anno$ensembl_gene_id[j]) {
          gene_anno$external_gene_name[j] <- paste0(gene_anno$external_gene_name[j], "-alt")
        }
      }
    }

    new_mat <- assay(data[rownames(data) %in% gene_anno$external_gene_name, ]) # Use `assay` to get mat from SE object.
    for (i in seq(nrow(dup))) {
      for (j in seq(nrow(data))) {
        if (dup$external_gene_name[i] == rownames(data)[j]) {
          new_row <- assay(data[j, ])
          rownames(new_row) <- paste0(rownames(new_row), "-alt")
          new_mat <- rbind(new_mat, new_row)
        }
      }
    }
  } else {
    new_mat <- assay(data[rownames(data) %in% gene_anno$external_gene_name, ]) # If no dups, just subset to `gene_anno`.
  }
  # ------------------------------------------------------------------------

  # Subset `gene_anno` to dataset rows and match order.
  # -------------------------------------------------
  gene_anno <- gene_anno[gene_anno$external_gene_name %in% rownames(new_mat), ]
  gene_anno <- gene_anno[order(match(gene_anno$external_gene_name, table = rownames(new_mat))), ]
  # -------------------------------------------------

  saveRDS(gene_anno, file = rds)
  saveRDS(new_mat, file = rds2)
  saveRDS(gene_sets, file = rds3)
}
# ------------------------------------------------------------------------------------------------------------

# Add Ensembl IDs to dataset.
# ---------------------------
rownames(new_mat) <- gene_anno$ensembl_gene_id
data_ENSG <- new_mat
rm(new_mat)
# ---------------------------

# Perform GSE using the ssGSEA method.
# ------------------------------------
gsva <- gsva(data_ENSG, gset.idx.list = gene_sets, method = "ssgsea", ssgsea.norm = FALSE, verbose = FALSE)
# ------------------------------------

# Apply limma for all pairwise comparisons as described.
# ------------------------------------------------------
limma_design <- model.matrix(~ 0 + experimental_design$groups)
colnames(limma_design) <- unique(experimental_design$groups)
contrast_mat <- makeContrasts(F1_3-F4_6, F1_3-F7_8, F4_6-F7_8, levels = limma_design)

fit <- lmFit(gsva, design = limma_design)
cont_fit <- eBayes(contrasts.fit(fit, contrasts = contrast_mat))
tests <- decideTests(cont_fit, method = "global", p.value = 5e-4)
# ------------------------------------------------------

# The only way to get a full stats table as described is to write it out as a TSV then read it back in.
# -----------------------------------------------------------------------------------------------------
write.fit(
  cont_fit, results = tests, file = file.path(cache_dir, "results.tsv"),
  adjust = "BH", method = "global", F.adjust = "BH"
)
results <- read.delim(file.path(cache_dir, "results.tsv"))
# -----------------------------------------------------------------------------------------------------

# Clean up table and sort by adjusted F p-value.
# ----------------------------------------------
rownames(results) <- results$X
results <- results[ , -1]
results <- results[order(results$F.p.value.adj), ]
# ----------------------------------------------

# Distinguish gene sets from different subontologies.
# ---------------------------------------------------
sub_ontology <- getGmt(file.path(data_dir, "gene-sets", "gprofiler_hsapiens.ENSG", "hsapiens.GO:BP.ENSG.gmt"))
GO_BP <- c()
for (i in seq(length(sub_ontology@.Data))) {
  GO_BP <- append(GO_BP, sub_ontology[[i]]@shortDescription)
}

sub_ontology <- getGmt(file.path(data_dir, "gene-sets", "gprofiler_hsapiens.ENSG", "hsapiens.GO:MF.ENSG.gmt"))
GO_MF <- c()
for (i in seq(length(sub_ontology@.Data))) {
  GO_MF <- append(GO_MF, sub_ontology[[i]]@shortDescription)
}

sub_ontology <- getGmt(file.path(data_dir, "gene-sets", "gprofiler_hsapiens.ENSG", "hsapiens.GO:CC.ENSG.gmt"))
GO_CC <- c()
for (i in seq(length(sub_ontology@.Data))) {
  GO_CC <- append(GO_CC, sub_ontology[[i]]@shortDescription)
}
# ---------------------------------------------------

# Merge subontology information into main stats table.
# ----------------------------------------------------
key_value <- data.frame(
  key = c(GO_BP, GO_MF, GO_CC),
  value = c(rep("GO_BP", length(GO_BP)), rep("GO_MF", length(GO_MF)), rep("GO_CC", length(GO_CC)))
)
results_names <- data.frame(names = rownames(results))
results$Ontology <- merge(results_names, key_value, by.x = "names", by.y = "key")$value
results <- results[ , c(ncol(results), 1:(ncol(results) - 1))] # Move `Ontology` column to the first column.
# ----------------------------------------------------

# Subset stats table to highlight specific significant comparison combinations.
# For example, `F1_3` describe terms that are enriched in `F1_3`, compared to both `F4_6` and `F7_8`.
# ---------------------------------------------------------------------------------------------------
tests_up <- tests[
  tests[ , 1] == 1 & tests[ , 2] == 1 & tests[ , 3] == 0 |
    tests[ , 1] == 1 & tests[ , 2] == 0 & tests[ , 3] == 0 |
    tests[ , 1] == 0 & tests[ , 2] == 1 & tests[ , 3] == 0,
]
F1_3 <- results[rownames(results) %in% rownames(tests_up), ]

tests_up <- tests[
  tests[ , 1] == -1 & tests[ , 3] == 1 & tests[ , 2] == 0 |
    tests[ , 1] == -1 & tests[ , 3] == 0 & tests[ , 2] == 0 |
    tests[ , 1] == 0 & tests[ , 3] == 1 & tests[ , 2] == 0,
]
F4_6 <- results[rownames(results) %in% rownames(tests_up), ]

tests_up <- tests[
  tests[ , 2] == -1 & tests[ , 3] == -1 & tests[ , 1] == 0 |
    tests[ , 2] == -1 & tests[ , 3] == 0 & tests[ , 1] == 0 |
    tests[ , 2] == 0 & tests[ , 3] == -1 & tests[ , 1] == 0,
]
F7_8 <- results[rownames(results) %in% rownames(tests_up), ]
# ---------------------------------------------------------------------------------------------------
```

## F1_3

```{r}
datatable_download(F1_3) # Custom version of `DT::datatable`, see top of file under "Define functions" comment.
```

## F4_6

```{r}
datatable_download(F4_6) # Custom version of `DT::datatable`, see top of file under "Define functions" comment.
```

## F7_8

```{r}
datatable_download(F7_8) # Custom version of `DT::datatable`, see top of file under "Define functions" comment.
```

# Figure 1C

A curated heatmap of enriched Gene Ontology (GO) terms selected from the tables above.
Per-row scaling is applied to accentuate differences between samples with the caveat of losing comparability between gene sets.

```{r, fig.height = 5, fig.width = 15}
select <- c(
  "stimulatory C-type lectin receptor signaling pathway",
  "heterophilic cell-cell adhesion via plasma membrane cell adhesion molecules",
  "excitatory extracellular ligand-gated ion channel activity",
  "proteoglycan binding",
  "juxtaparanode region of axon",
  "anchored component of external side of plasma membrane",
  "receptor recycling",
  "vesicle-mediated transport between endosomal compartments",
  "protein folding chaperone",
  "tau protein binding",
  "early phagosome",
  "retromer complex",
  "cytochrome complex assembly",
  "mitochondrial protein processing",
  "quinone binding",
  "fatty-acyl-CoA binding",
  "nucleoid",
  "tricarboxylic acid cycle enzyme complex"
)
heatmap_data <- gsva[rownames(gsva) %in% select, ]
heatmap_data <- heatmap_data[match(select, table = rownames(heatmap_data)), ]
colnames(heatmap_data) <- data$nice_names

# Apply min-max scaling to each row independently so that values lie between -1 and 1.
# ------------------------------------------------------------------------------------
heatmap_data <- t(apply(heatmap_data, MARGIN = 1, FUN = function (x) ((2 * (x - min(x)) / (max(x) - min(x))) - 1)))
heatmap_color <- colorRamp2(c(-1, 0, 1), c("#0077BB", "#FFFFFF", "#CC3311"))
# ------------------------------------------------------------------------------------

set.seed(1)
draw(
  Heatmap(
    heatmap_data,
    col = heatmap_color,
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(heatmap_data)),
    heatmap_legend_param = list(
      title = "Per-row Scaled ssGSEA Enrichment", direction = "horizontal",
      legend_width = unit(7.5, "cm")
    ),
    row_names_gp = gpar(fontsize = 10),
    column_names_gp = gpar(fontsize = 10),
    rect_gp = gpar(col = "grey", lwd = 1)
  ),
  heatmap_legend_side = "top"
)
```

# References

This is the concluding section of the document, where we output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
